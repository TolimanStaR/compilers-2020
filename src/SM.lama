-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N


fun eval (condition, instance) {
	case condition of [stack, state, world@[in, out]] -> 
		case instance of
			  {} -> condition 
			| Binop (binop) : remaining -> case stack of left : right : stack__ -> eval([parse_bin_operation(binop, left, right) : stack__,state,world], remaining) esac
			| Const(n) : remaining -> eval([n : stack, state, world], remaining)
			| Read : remaining -> case in of elem : in__ -> eval([elem : stack, state, [in__, out]], remaining) esac
			| Write : remaining -> case stack of elem : stack__ -> eval([stack__, state, [in, elem : out]], remaining) esac
			| LD(elem) : remaining -> eval([st(elem) : stack, state, world], remaining)
			| ST(elem) : remaining -> case stack of other : stack__ -> eval([stack, (state <- [elem, other]), world], remaining) esac
		esac
	esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
	eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expression) {
	case expression of
		    Const(n) -> singleton(expression)
		  | Var(x) -> singleton(LD(x))
		  | Binop(binop, left, right) -> compileExpr(left) +++ compileExpr(right) +++ Binop(binop)
	esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.

public fun compileSM (statement) {
	case statement of
		  Assn(elem, expression) -> [compileExpr(expression), ST(elem)]
		| Read(elem) -> [READ, ST(x)]
		| Write(elem) -> [compileExpr(elem), WRITE]
		| Seq(fi, se) -> compileSM(fi) +++ compileSM(se)
	esac
}
